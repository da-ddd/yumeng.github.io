<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>南有乔木</title><link>https://da-ddd.github.io/myapp</link><description>多多请教</description><copyright>南有乔木</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/171486473?v=4&amp;size=64</url><title>avatar</title><link>https://da-ddd.github.io/myapp</link></image><lastBuildDate>Wed, 24 Jul 2024 06:35:42 +0000</lastBuildDate><managingEditor>南有乔木</managingEditor><ttl>60</ttl><webMaster>南有乔木</webMaster><item><title>Promise入门</title><link>https://da-ddd.github.io/myapp/post/Promise-ru-men.html</link><description># Promise入门&#13;
Promise是ES6规范中的一门新技术，它是一个构造函数，用来封装一个异步操作并且可以获取其成功/失败的结果值&#13;
### 创建Promise实例对象&#13;
```javascript&#13;
const p=new Promise((resolve,reject)=&gt;{&#13;
     resolve('Success'); // 异步操作成功时调用&#13;
     reject('Error'); // 失败时调用&#13;
})&#13;
```&#13;
&#13;
- Pending未决定的&#13;
- Resolved	/ Fullfiled 成功&#13;
- Rejected 失败&#13;
&#13;
Resolve调用后可以将promise对象的状态设置为成功&#13;
Reject 调用后可以将promise对象的状态设置为失败&#13;
&#13;
- Pending=&gt;resolved/ fullfiled  &#13;
- Pending=&gt;rejected&#13;
&#13;
只有这两种情况，且一个promise对象只能改变一次&#13;
Resolve和reject函数可以传参数，之后在then的两个回调函数里面可以接收到&#13;
### 指定回调函数&#13;
调用then方法&#13;
then有两个参数并且都是函数，第一个是promise对象成功的回调，第二个是失败回调&#13;
```javascript&#13;
p.then((value)=&gt;{&#13;
        console.log(value)&#13;
},(reason)=&gt;{&#13;
        console.log(reason)&#13;
})&#13;
```&#13;
### API&#13;
&#13;
**Promise(excutor){}**&#13;
Excutor函数:执行器(resolve,reject)=&gt;{}&#13;
resolve函数：内部定义成功时就调用 value=&gt;{}&#13;
reject函数：内部定义失败时就调用 reason=&gt;{}&#13;
说明：excutor会在Promise内部立即同步调用，异步操作会在执行器中执行&#13;
&#13;
**Promise.prototype.then**&#13;
实例对象.then(成功回调，失败回调) &#13;
说明：返回一个新的promise对象&#13;
返回的promisei结果由then()指定的回调函数执行的结果决定&#13;
&#13;
**Promise.prototype.catch**&#13;
失败回调函数&#13;
p.catch(reason=&gt;{...}) &#13;
&#13;
**promise.resolve**&#13;
```javascript&#13;
let p1=promise.resolve(233)&#13;
Let p2=promise.resolve(new Promise((Resolve,Reject)=&gt;{&#13;
Resolve(‘OK’)&#13;
}))&#13;
//如果传入的参数为非promise类型对象，则返回的结果为成功promise对象&#13;
//如果传入的参数为promise对象，则参数的结果决定了resolve的结果&#13;
```&#13;
&#13;
**promise.reject**&#13;
```javascript&#13;
let p1=promise.reject(233);&#13;
//返回的结果永远是失败的，即使参数是一个promise实例对象并且成功&#13;
```&#13;
&#13;
**promise.all**&#13;
参数是包括了n个promise的数组&#13;
说明：返回一个新的promise，只有数组中所有的promise都成功才成功，只要有一个失败就直接失败&#13;
```javascript&#13;
let p1=new promise((resolve,reject)=&gt;{resolve(“OK”)})&#13;
let p2=promise.resolve(“Success”)&#13;
let p3=promise=resolve(“yes”)&#13;
const result=promise.all([p1,p2,p3])&#13;
```&#13;
&#13;
**promise.race**&#13;
参数是包括了n个promise的数组&#13;
说明：返回一个新的promise，第一个完成的promise的结果就是最终的结果状态&#13;
```javascript&#13;
const result=promise.race([p1,p2,p3])&#13;
//由p1决定结果&#13;
```&#13;
&#13;
**promise状态**&#13;
除了resolve和reject可以修改promise状态&#13;
还可以用throw（抛出）&#13;
```javascript&#13;
throw 'error';&#13;
```&#13;
&#13;
**多个回调函数**&#13;
一个promise指定多个失败/成功回调，当promise改为对应状态时都会调用&#13;
&#13;
**执行顺序**&#13;
正常情况是先指定回调再改变状态，但也可以先改变状态再指定回调&#13;
先改变状态再指定回调：&#13;
&#13;
- 在执行中直接调用resolve或者reject&#13;
- 延迟更长时间才调用then&#13;
&#13;
先指定回调再改变状态：&#13;
&#13;
- 当实例对象中是一个异步任务的时候&#13;
&#13;
**串联多个任务**&#13;
链式调用：&#13;
then返回一个新的promise，可以开成then的链式调用&#13;
通过then的链式调用串联多个同步/异步任务&#13;
```javascript&#13;
 let p =new Promise((resolve,reject)=&gt;{&#13;
        setTimeout(()=&gt;{	&#13;
            resolve('OKK')&#13;
        },1000)&#13;
       })&#13;
p.then(value=&gt;{&#13;
    return new Promise((resolve,reject)=&gt;{&#13;
        resolve('success')&#13;
    })&#13;
}).then(value=&gt;{&#13;
    console.log(value) // success&#13;
}).then(value=&gt;{&#13;
    console.log(value) // undefined&#13;
})&#13;
```&#13;
&#13;
**异常穿透**&#13;
当使用promise的then链式调用时候，可以在最后指定失败的回调&#13;
前面任何操作出了异常，都会传到最后失败的回调中处理&#13;
```javascript&#13;
 let p =new Promise((resolve,reject)=&gt;{&#13;
        setTimeout(()=&gt;{	&#13;
            resolve('OKK')&#13;
        },1000)&#13;
       })&#13;
p.then(value=&gt;{&#13;
    return new Promise((resolve,reject)=&gt;{&#13;
        resolve('success')&#13;
    })&#13;
}).then(value=&gt;{&#13;
    console.log(value) // success&#13;
}).then(value=&gt;{&#13;
    console.log(value) // undefined&#13;
}).catch((reason)=&gt;{ &#13;
console.log(reason);&#13;
})&#13;
```&#13;
在最后加.catch(reason=&gt;{...})，使用then也行&#13;
&#13;
**中断promise链**&#13;
当使用promise链式调用时，在中间中断，不在调用后面的回调函数&#13;
方法：在回调函数中返回一个pendding状态的promise&#13;
```javascript&#13;
return new promise(()=&gt;{})&#13;
```&#13;
&#13;
**Async**&#13;
函数的返回值为promise对象&#13;
Promise对象的结果由async函数执行的返回值决定&#13;
&#13;
- 如果返回值是一个非promise类型的数据，结果就是成功的&#13;
- 如果返回值是一个promise对象，resolve就成功，reject就失败&#13;
- 如果是抛出异常(throw)，结果是一个失败的promise对象&#13;
&#13;
```javascript&#13;
async function main(){&#13;
     return new Promise((resolve,reject)=&gt;{&#13;
          resolve()&#13;
})&#13;
}&#13;
Let result =main()&#13;
//它和then方法返回规则是一样的&#13;
```&#13;
&#13;
**await**&#13;
await右侧的表达式一般为promise对象，但也可以是其他值&#13;
&#13;
- 如果表达式是promise对象，await返回的是promise成功的值&#13;
- 如果表达式是其他的值，直接将此值作为await的返回值&#13;
注意：&#13;
await必须写在async函数中，但async函数中可以没有await&#13;
如果await的promise失败了，就会抛出异常，需要同过try...catch捕获处理&#13;
```javascript&#13;
 try {&#13;
            let result = await new Promise((resolve,reject)=&gt;{&#13;
                reject()&#13;
             })              &#13;
} catch (error) {&#13;
       reject(error)&#13;
}&#13;
```&#13;
&#13;
**async和await结合实践**&#13;
```javascript&#13;
try{&#13;
     let data1=await _promise对象_&#13;
     let data2=await _promise对象_&#13;
     let data3=await _promise对象_&#13;
}catch(error){&#13;
     console.log(error)&#13;
}&#13;
```&#13;
&#13;
**事件循环机制**&#13;
async函数在抛出返回值时，会根据返回值类型开启不同数目的微任务&#13;
&#13;
- return结果值：非thenable、非promise（不等待）&#13;
- return结果值：thenable（等待 1个then的时间）&#13;
- return结果值：promise（等待 2个then的时间）&#13;
&#13;
await右值类型区别&#13;
&#13;
- 接非 thenable 类型，会立即向微任务队列添加一个微任务then，但不需等待&#13;
- &#13;
- 接 thenable 类型，需要等待一个 then 的时间之后执行&#13;
- &#13;
- 接Promise类型(有确定的返回值)，会立即向微任务队列添加一个微任务then，但不需等待&#13;
- &#13;
- TC 39 对await 后面是 promise 的情况如何处理进行了一次修改，移除了额外的两个微任务，在早期版本，依然会等待两个 then 的时间&#13;
。</description><guid isPermaLink="true">https://da-ddd.github.io/myapp/post/Promise-ru-men.html</guid><pubDate>Wed, 24 Jul 2024 04:27:40 +0000</pubDate></item><item><title>三种判断数组方法的区别</title><link>https://da-ddd.github.io/myapp/post/san-zhong-pan-duan-shu-zu-fang-fa-de-qu-bie.html</link><description>### 下列组的方法&#13;
**Object.prototype.toString.call()&#13;
Instanceof&#13;
Array.isArray()**&#13;
 **第一种**&#13;
```javascript&#13;
Object.prototype.toString.call(an); // '[object Array]'&#13;
```&#13;
每一个继承object的对象都有tostring方法，如果tostring方法没有重写的话会返回object.type，其中type为对象的类型，但是当除了objectl类型的对象外，其他类型直接使用tostring方法时候，会直接返回都是内容的字符串，所以需要使用call或者apply方法来改变tostring方法的执行&#13;
Object.prototype.toString.call()方法对于所有基本的数据类型都能进行判断，即使是null或者undefined,常用于判断浏览器的内置对象&#13;
 **第二种**&#13;
```javascript&#13;
instanceof Array; // true&#13;
instanceof Object; // true&#13;
```&#13;
Instanceof()的内部机制是通过判断对象的原型链中是不是能找到类型的proptotpye&#13;
使用instanceof判断一个对象是否为数组，instanceof会判断这个对象的原型链上是否会找到对象的Array的原型，找到返回true，反则&#13;
但是instanceof只能用来判断对象类型，原始类型不可以，并且所有对象类型Instanceof object都是true&#13;
 **第三种**&#13;
Array.isArray()用来判断对象是否为数组&#13;
Instanceof和isArray对比&#13;
当检测Array实例时，isArray优于Instanceof，因为他可以检测出iframes&#13;
```javascript&#13;
var iframe = document.createElement('iframe');&#13;
document.body.appendChild(iframe);&#13;
xArray = window.frames[window.frames.length-1].Array;&#13;
var arr = new xArray(1,2,3); // [1,2,3]&#13;
&#13;
// Correctly checking for Array&#13;
Array.isArray(arr);  // true&#13;
Object.prototype.toString.call(arr); // true&#13;
// Considered harmful, because doesn't work though iframes&#13;
arr instanceof Array; // false&#13;
```&#13;
isArray与tostring对比&#13;
isArray是ES5新增的方法，当不存在isArray时候，可以用tostring实现&#13;
```javascript&#13;
if (!Array.isArray) {&#13;
  Array.isArray = function(arg) {&#13;
    return Object.prototype.toString.call(arg) === '[object Array]';&#13;
  };&#13;
}	&#13;
```。</description><guid isPermaLink="true">https://da-ddd.github.io/myapp/post/san-zhong-pan-duan-shu-zu-fang-fa-de-qu-bie.html</guid><pubDate>Mon, 22 Jul 2024 12:23:32 +0000</pubDate></item></channel></rss>